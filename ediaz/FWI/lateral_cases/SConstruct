'''
this script is made for testing the 
time-domain implementation of Tony's MVA
method. 

The test is performed with a constant velocity
medium. 

Three models are used: 
- Low       (-20% anomaly)
- Correct   (  0% anomaly)
- High      (+20% anomaly)
'''

from rsf.proj import *
import fdmod,encode,wei,adcig,wemig
import math

# ------------------------------------------------------------
par = {
    'nx':300, 'ox':0, 'dx':0.02,  'lx':'x', 'ux':'km',
    'ny':1,   'oy':0, 'dy':0.02,  'ly':'y', 'uy':'km',
    'nz':250, 'oz':0, 'dz':0.01,  'lz':'z', 'uz':'km',
    'nt':2000,'ot':0, 'dt':0.002, 'lt':'t', 'ut':'s',
    'kt':180,
    'jsnap':100,
    'nb':100,
    'frq':15,
    'ns':10,'os':0.0,'ds':0.25,'oxs':1.0
    }
fdmod.param(par)
# ------------------------------------------------------------
# EIC computational domain
par['nhz']=0
par['nhx']=100
par['nhz']=par['nhx']
par['nht']=120
par['dht']=par['dt']*2

adcig.tparam((par['nhx']*par['dx'])/(par['nht']*par['dt']),
             2*par['nht']+1,-par['nht']*par['dt'],par['dt'],
               par['nz']   ,            par['oz'],par['dz'],
             par)

adcig.xparam(
             2*par['nhx']+1,-par['nhx']*par['dx'],par['dx'],
               par['nz']   ,            par['oz'],par['dz'],
             par)

adcig.eparam(10.0,
             2*par['nhx']+1,-par['nhx']*par['dx'],par['dx'],
             2*par['nhz']+1,-par['nhz']*par['dz'],par['dz'],
             2*par['nht']+1,-par['nht']*par['dt'],par['dt'],
             par)
# ------------------------------------------------------------


par['impulse']='n'

# taper parameters
par['xk']=50
par['yk']=50
par['xl']=par['nx']-50
par['yl']=par['ny']-50

# migration parameters
par['jw']=1
par['ow']=2
par['nw']=72
par['dw']=1/(par['nt']*par['dt'])

# deconvolution regularization
par['deps']=1e-5

# lag parameters
par['nhz']=0
par['nhx']=60
par['nhy']=0
par['nht']=220
par['mht']=2*par['nht']+1
par['dht']=  par['dt'] *2
par['oht']= -par['nht']*par['dht']
par['tratio']=1.0
par['xratio']=1.0
par['lratio']=1.0

# ------------------------------------------------------------
# source/receiver coordinates
# ------------------------------------------------------------

# source coordinates:

for ishot in range(par['ns']):
    stag='-%03d'%ishot
 
    zx=ishot*par['ds']+par['os']
    fdmod.point('s'+stag,par['oxs'],zx,par)
    Plot('s'+stag,fdmod.ssplot('',par))



Flow('ss',map(lambda x:'s-%03d'%x,range(par['ns'])), 'rcat axis=2 space=n ${SOURCES[1:%s]}'%(par['ns']))
Plot('ss',fdmod.ssplot('',par))








# receiver coordinates:
fdmod.vertical('rr',5.0,par)
Plot('rr',fdmod.rrplot('',par))

# tlag gather coordinates:
fdmod.vertical('gg',3.0,par)
Plot('gg',fdmod.rrplot('plotcol=2',par))


# ------------------------------------------------------------
# Cig locations
# ------------------------------------------------------------
par['ogx'] = 1.30
par['dgx'] = 0.1
par['ngx'] = 35

ggloc=range(par['ngx'])

for g in ggloc:
    gtag='-%03d'%g
    fdmod.vertical('gg'+gtag,par['ogx']+g*par['dgx'],par)
    Plot('gg'+gtag,fdmod.rrplot('plotcol=2',par))
    


# ------------------------------------------------------------
# model parameters
# ------------------------------------------------------------
par['vp']=2.0
par['ro']=2.0

# ------------------------------------------------------------
# density
# ------------------------------------------------------------
Flow('den',None,
    '''
    math  n1=%(nz)d o1=%(oz)g d1=%(dz)g
          n2=%(nx)d o2=%(ox)g d2=%(dx)g output="1.0"
    '''%par)

# velocity
# lateral gradient
#Flow('vel-L','den','math output=" %(vp)g +(1/(%(ox)g+(%(nx)d-1)*%(dx)g))*(x2-5.0) "'%par)
#Flow('vel-C','den','math output="%g"' %par['vp'])
#Flow('vel-H','den','math output=" %(vp)g -(1/(%(ox)g+(%(nx)d-1)*%(dx)g))*(x2-5.0) "'%par)

# constant error


Flow('vel-C','den','math output="%g"' %par['vp'])

par['cx']=(par['ox']+(par['nx']-1)*par['dx'])*.5
par['sx']=par['nx']*par['dx']*0.08

par['cz']=(par['oz']+(par['nz']-1)*par['dz'])*.5
par['sz']=par['sx']



Flow('box','vel-C','math output="exp(-((x1-%(cz)g)^2/(%(sz)g)^2+(x2-%(cx)g)^2/(%(sx)g)^2))" '%par)

Flow('vel-L','box vel-C',' math vc=${SOURCES[1]} output="vc- 0.3*vc "')
Flow('vel-H','box vel-C',' math vc=${SOURCES[1]} output="vc+ 0.3*vc "')


# Plot velocities
Flow(['vels-byte','vels-bar'],['vel-L','vel-C','vel-H'],'cat axis=3 ${SOURCES[1:3]} |byte gainpanel=a allpos=y color=j bias=1.5 bar=${TARGETS[1]}')
i=0
for v in (['-L','-C','-H']):
    Plot('vel'+v,['vels-byte','vels-bar'],'window f3=%d n3=1 |'%i +fdmod.cgrey('bar=${SOURCES[1]} color=j ',par))
    i+=1

# Overlay velocities with sources, receivers and eic locations
for i in (['vel-L','vel-C','vel-H']):
    Result(i,[i,'rr','gg','ss'],'Overlay')

# ------------------------------------------------------------
# wavelet
fdmod.wavelet('wav_',par['frq'],par)
Flow(  'wav','wav_','transp')
Result('wav','transp |' + fdmod.waveplot('',par))

# Generate data with true model
for ishot in range(par['ns']):
    stag='-%03d'%ishot
    fdmod.awefd_data('dat_s'+stag,'wav','vel-C','den','s'+stag,'rr','jsnap=2',par)




# ------------------------------------------------------------
# I will test the gradient calculation using 4 different 
# cases:
#
# 1: 1 source , 1 receiver , 1   cip location
# 2: 1 source , n receivers, n   cip location
# 3: n sources, n receivers, n   cip location
# 4: n sources, n receivers, n   cip locations 
# 4: n sources, n receivers, n^2 cip locations 
#
# array case contain all these variables
# ------------------------------------------------------------

case0=[[5],125,125]
case1=[[5],125,17]
case2=[[3],[range(par['nz'])],17]
case3=[range(par['ns']),[range(par['nz'])],17]
case4=[range(par['ns']),[range(par['nz'])],range(par['ngx'])]

cases=[case0,case1,case2,case3,case4]


for m in (['-L','-C','-H']):


    




    ci=0

    for c in cases:
        ctag='-c%d'%ci 
    
        shots=c[0]


        ##########################################################################################
        #          Read and process the cases table, each case separately to make 
        #          sure it makes what I want it to do.
        ##########################################################################################
        if  ci==0:
            Flow('rr'+ctag,'rr','window f2=%s n2=1'%c[1])
            fdmod.point('gg'+ctag,3.0,c[2]*par['dz'] +par['oz'],par)

        elif ci==1:
            Flow('rr'+ctag,'rr','window f2=%s n2=1'%c[1])
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
        elif ci==2:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
        elif ci==3:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
        elif ci==4:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,map(lambda x:'gg-%03d'%x,c[2]),'cat axis=2 ${SOURCES[1:%d]}'%len(c[2]))
        else:
            print "something wrong, probably I going to crash"
        ##########################################################################################
        ##########################################################################################


        Plot('gg'+ctag,fdmod.rrplot('plotcol=2',par))
        Plot('rr'+ctag,fdmod.ssplot('',par))
        Plot('ss'+ctag,map(lambda x:'s-%03d'%x,shots),'Overlay')


        for ishot in shots:
            stag='-%03d'%ishot

            if ci<2:
                Flow('dat_s'+stag+ctag,'dat_s-%03d'%ishot,'window f1=%s n1=1 squeeze=n'%c[1])
            else:
                Flow('dat_s'+stag+ctag,'dat_s-%03d'%ishot,'window squeeze=n')


                   
            # Computing state variables us and ur
            fdmod.awefd('dmod'+ctag+stag+m,'us'+ctag+stag+m,'wav','vel'+m,'den','s'+stag,'rr'+ctag,'jsnap=2',par)
            
            Flow('dres'+ctag+stag+m,['dmod'+ctag+stag+m,'dat_s'+stag+ctag],'add scale=-1,1 ${SOURCES[1]}')

            fdmod.awefd_rwfl('ur'+ctag+stag+m,'dres'+ctag+stag+m,'vel'+m,'den','rr'+ctag,'jsnap=2',par)

            # Compute of conventional image
            Flow('img'+ctag+stag+m,['us'+ctag+stag+m,'ur'+ctag+stag+m],
                ''' 
                xcor2d uu=${SOURCES[1]} axis=3 verb=y nbuf=100
                ''' % par)
    
            # Extended imaging condition and only one location for every shot
            wemig.eic('eic'+ctag+stag+m,'us'+ctag+stag+m,'ur'+ctag+stag+m,'gg'+ctag,'nhx=0 nhz=0 nht=%(nht)d|window squeeze=y'%par,par)


#            if len(shots)>1:
#                Flow('eic'+ctag+m,map(lambda x:'eic'+ctag+'-%03d'%x+m,shots),'cat axis=3 ${SOURCES[1:%d]} |stack axis=3 '%len(shots))
#            else:
             Flow('eic'+ctag+m,'eic'+ctag+stag+m,'window')
    


        # Create mask based on zero \tau trace:

        Flow('mask_eic'+ctag+m,'eic'+ctag+m,'window n1=1 min1=0 |envelope|scale axis=123|math output="input^2"| spray axis=1 n=441 d=0.002 o=-0.44')
    
        # Penalized time-lag gather
        if ci<1:
            Flow('pen_eic'+ctag+m,['eic'+ctag+m],'math output="input*x1"|bandpass flo=5') 
        else:
            Flow('pen_eic'+ctag+m,['eic'+ctag+m,'mask_eic'+ctag+m],'math output="input*x1"|add mode=p ${SOURCES[1]}') 



        

        for ishot in shots:
            stag='-%03d'%ishot
            # Adjoint source, receiver side
            Flow('adj_r'+ctag+stag+m,['us'+ctag+stag+m,'pen_eic'+ctag+m,'gg'+ctag,'wav_'],
                 '''
                 ./sfadjsrc_mva2.exe eic=${SOURCES[1]} coord=${SOURCES[2]} source=1 verb=1 |
                  sinc pattern=${SOURCES[3]} | transp plane=12 
                 ''')
            # Adjoint source, source side
            Flow('adj_s'+ctag+stag+m,['ur'+ctag+stag+m,'pen_eic'+ctag+m,'gg'+ctag,'wav_'],
                 '''
                 ./sfadjsrc_mva2.exe eic=${SOURCES[1]} coord=${SOURCES[2]} source=0 verb=1 |
                 sinc pattern=${SOURCES[3]} | transp plane=12 
                 ''')
    
            # Adjoint state variables
            custom='jsnap=2 '
            fdmod.awefd_rwfl('as'+ctag+stag+m,'adj_s'+ctag+stag+m,'vel'+m,'den','gg'+ctag,custom,par)
            fdmod.awefd_swfl('ar'+ctag+stag+m,'adj_r'+ctag+stag+m,'vel'+m,'den','gg'+ctag,custom,par)
    
            # Gradient calculation 
            # sgrad:  source side gradient 
            #      sgrad = \int us*as dt
            # rgrad:  source side gradient 
            #      rgrad = \int ur*ar dt
    
            custom='deriv3 axis=3|deriv3 axis=3 |xcor2d uu=${SOURCES[1]} axis=3 verb=y nbuf=100'
            Flow('sgrad'+ctag+stag+m,['us'+ctag+stag+m,'as'+ctag+stag+m],custom)
            Flow('rgrad'+ctag+stag+m,['ur'+ctag+stag+m,'ar'+ctag+stag+m],custom)
    
    
            #plotting of gradients
            Plot('sgrad'+ctag+stag+m,fdmod.cgrey('color=E ',par))
            Result('sgrad'+ctag+stag+m,['sgrad'+ctag+stag+m,'gg'+ctag,'rr'+ctag,'ss'+ctag],'Overlay')

            Plot('rgrad'+ctag+stag+m,fdmod.cgrey('color=E ',par))
            Result('rgrad'+ctag+stag+m,['rgrad'+ctag+stag+m,'gg'+ctag,'rr'+ctag,'ss'+ctag],'Overlay')




        # stack of individual gradient contributions
        # total source gradient
        Flow('sgrad'+ctag+m,map(lambda x:'sgrad'+ctag+'-%03d'%x+m,shots),'cat axis=3 ${SOURCES[1:%d]}|stack axis=3'%len(shots))
   

        Result('sgrad'+ctag+m,map(lambda x:'sgrad'+ctag+'-%03d'%x+m,shots),'Movie')
 
        # totall receiver gradient
        Flow('rgrad'+ctag+m,map(lambda x:'rgrad'+ctag+'-%03d'%x+m,shots),'cat axis=3 ${SOURCES[1:%d]}|stack axis=3'%len(shots))
        Result('rgrad'+ctag+m,map(lambda x:'rgrad'+ctag+'-%03d'%x+m,shots),'Movie')
    
        # total gradient:  sgrad + rgrad
        Flow('grad'+ctag+m,['sgrad'+ctag+m,'rgrad'+ctag+m],'add ${SOURCES[1]} ')
    



        Plot('case'+ctag,['ss'+ctag,'gg'+ctag,'rr'+ctag],'Overlay')


        ci+=1



ci=0
for c in cases:
    ctag='-c%d'%ci 

    Flow('grad-byte'+ctag,map(lambda x:'grad'+ctag+'%s'% x,['-L','-C','-H']),'rcat axis=3 ${SOURCES[1:3]}|scale axis=3|byte gainpanel=a pclip=99.5')


    nm=0
    for m in (['-L','-C','-H']):
        
        Plot('grad'+ctag+m,'grad-byte'+ctag,'window f3=%d n3=1 |'%nm+fdmod.cgrey('color=E ',par))

        Result ('grad'+ctag+m,['grad'+ctag+m,'ss'+ctag,'rr'+ctag,'gg'+ctag],'Overlay')
    
        nm+=1 


    ci+=1

End()
