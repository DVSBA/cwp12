'''
this script is made for testing the 
time-domain implementation of Tony's MVA
method. 

The test is performed with a constant velocity
medium. 

Three models are used: 
- Low       (-20% anomaly)
- Correct   (  0% anomaly)
- High      (+20% anomaly)
'''

from rsf.proj import *
import fdmod,encode,wei,adcig,wemig
import math

# ------------------------------------------------------------
par = {
    'nx':600, 'ox':0, 'dx':0.01,  'lx':'x', 'ux':'km',
    'ny':1,   'oy':0, 'dy':0.02,  'ly':'y', 'uy':'km',
    'nz':250, 'oz':0, 'dz':0.01,  'lz':'z', 'uz':'km',
    'nt':3500,'ot':0, 'dt':0.001, 'lt':'t', 'ut':'s',
    'kt':180,
    'jsnap':100,
    'nb':100,
    'frq':10,
    'ns':10,'os':0.0,'ds':0.25,'oxs':1.0
    }
fdmod.param(par)
# ------------------------------------------------------------
# EIC computational domain
par['nhz']=0
par['nhx']=100
par['nhz']=par['nhx']
par['nht']=220
par['dht']=par['dt']*2

adcig.tparam((par['nhx']*par['dx'])/(par['nht']*par['dt']),
             2*par['nht']+1,-par['nht']*par['dt'],par['dt'],
               par['nz']   ,            par['oz'],par['dz'],
             par)

adcig.xparam(
             2*par['nhx']+1,-par['nhx']*par['dx'],par['dx'],
               par['nz']   ,            par['oz'],par['dz'],
             par)

adcig.eparam(10.0,
             2*par['nhx']+1,-par['nhx']*par['dx'],par['dx'],
             2*par['nhz']+1,-par['nhz']*par['dz'],par['dz'],
             2*par['nht']+1,-par['nht']*par['dt'],par['dt'],
             par)
# ------------------------------------------------------------


par['impulse']='n'

# taper parameters
par['xk']=100
par['yk']=50
par['zk']=100
par['xl']=par['nx']-par['xk']
par['zl']=par['nz']-par['zk']
par['yl']=par['ny']-par['yk']

# migration parameters
par['jw']=1
par['ow']=2
par['nw']=72grad-c1-L.rsf grad-c1-C.rsf grad-c1-H.rsf
par['dw']=1/(par['nt']*par['dt'])

# deconvolution regularization
par['deps']=1e-5

# lag parameters
par['nhz']=0
par['nhx']=60
par['nhy']=0
par['nht']=220
par['mht']=2*par['nht']+1
par['dht']=  par['dt'] *2
par['oht']= -par['nht']*par['dht']
par['tratio']=1.0
par['xratio']=1.0
par['lratio']=1.0

# ------------------------------------------------------------
# source/receiver coordinates
# ------------------------------------------------------------

# source coordinates:

for ishot in range(par['ns']):
    stag='-%03d'%ishot
 
    zx=ishot*par['ds']+par['os']
    fdmod.point('s'+stag,par['oxs'],zx,par)
    Plot('s'+stag,fdmod.ssplot('',par))



Flow('ss',map(lambda x:'s-%03d'%x,range(par['ns'])), 'rcat axis=2 space=n ${SOURCES[1:%s]}'%(par['ns']))
Plot('ss',fdmod.ssplot('',par))








# receiver coordinates:
fdmod.vertical('rr',5.0,par)
#Flow('rr','rr_tmp','window j2=%d'%int(par['ds']/par['dz']))


Plot('rr',fdmod.rrplot('',par))

# tlag gather coordinates:
fdmod.vertical('gg',3.0,par)
Plot('gg',fdmod.rrplot('plotcol=2',par))


# ------------------------------------------------------------
# Cig locations
# ------------------------------------------------------------
par['ogx'] = 1.30
par['dgx'] = 0.1
par['ngx'] = 35

ggloc=range(par['ngx'])



for g in ggloc:
    gtag='-%03d'%g
    fdmod.vertical('gg'+gtag,par['ogx']+g*par['dgx'],par)
    Plot('gg'+gtag,fdmod.rrplot('plotcol=2',par))
    


# ------------------------------------------------------------
# model parameters
# ------------------------------------------------------------
par['vp']=2.0
par['ro']=2.0

# ------------------------------------------------------------
# density< ur-c0-005-L.rsf ./sfadjsrc_mva2_omp.exe eic=pen_eic-c0-005-L.rsf coord=gg-c0.rsf source=0 verb=1 
# ------------------------------------------------------------
Flow('den',None,
    '''
    math  n1=%(nz)d o1=%(oz)g d1=%(dz)g
          n2=%(nx)d o2=%(ox)g d2=%(dx)g output="1.0"
    '''%par)





# velocity
# lateral gradient
#Flow('vel-L','den','math output=" %(vp)g +(1/(%(ox)g+(%(nx)d-1)*%(dx)g))*(x2-5.0) "'%par)
#Flow('vel-C','den','math output="%g"' %par['vp'])
#Flow('vel-H','den','math output=" %(vp)g -(1/(%(ox)g+(%(nx)d-1)*%(dx)g))*(x2-5.0) "'%par)

# constant error


Flow('vel-C','den','math output="%g"' %par['vp'])

par['cb_x']=3.0
par['cb_z']=1.25
par['cb_a']=1.5

Flow('box','vel-C','math output="abs(x2-%g)"|mask max=%g |dd type=float >tmp1.rsf; <${SOURCES[0]} $RSFROOT/bin/sfmath  output="abs(x1-%g)"|mask max=%g |dd type=float |add mode=p tmp1.rsf>${TARGETS[0]} ; $RSFROOT/bin/sfrm tmp1.rsf'%(par['cb_x'],par['cb_a']*0.5,par['cb_z'],par['cb_a']*0.5),stdout=0)



par['cx']=(par['ox']+(par['nx']-1)*par['dx'])*.5
par['sx']=par['nx']*par['dx']*0.08

par['cz']=(par['oz']+(par['nz']-1)*par['dz'])*.5
par['sz']=par['sx']




Flow('vel-L','vel-C box',' math b=${SOURCES[1]}  output="input*(1.0-b) +b*sqrt(1/(1.3*(1/%g)^2))"'%par['vp'])
Flow('vel-H','vel-C box',' math b=${SOURCES[1]}  output="input*(1.0-b) +b*sqrt(1/(0.7*(1/%g)^2))"'%par['vp'])


# Plot velocities
Flow(['vels-byte','vels-bar'],['vel-L','vel-C','vel-H'],'cat axis=3 ${SOURCES[1:3]} |byte gainpanel=a allpos=y color=j bias=1.5 bar=${TARGETS[1]}')
i=0
for v in (['-L','-C','-H']):
    Plot('vel'+v,['vels-byte','vels-bar'],'window f3=%d n3=1 |'%i +fdmod.cgrey('bar=${SOURCES[1]} color=j ',par))
    i+=1

# Overlay velocities with sources, receivers and eic locations
for i in (['vel-L','vel-C','vel-H']):
    Result(i,[i,'rr','gg','ss'],'Overlay')

# ------------------------------------------------------------
# wavelet
fdmod.wavelet('wav_',par['frq'],par)
Flow(  'wav','wav_','transp')
Result('wav','transp |' + fdmod.waveplot('',par))


# Generate data with true model
for ishot in range(par['ns']):
    stag='-%03d'%ishot
    fdmod.awefd_data('dat_tmps'+stag,'wav','vel-C','den','s'+stag,'rr','',par)
    Flow('dat_s'+stag,['dat_tmps'+stag],'window ')



# ------------------------------------------------------------
# I will test the gradient calculation using 4 different 
# cases:
#
# 1: 1 source , 1 receiver , 1   cip location
# 2: 1 source , n receivers, n   cip location
# 3: n sources, n receivers, n   cip location
# 4: n sources, n receivers, n   cip locations 
# 4: n sources, n receivers, n^2 cip locations 
#
# array case contain all these variables
# ------------------------------------------------------------

case0=[[5],5,125]
case1=[[5],5,17]
case2=[[5],[range(par['ns'])],17]
case3=[range(par['ns']),[range(par['ns'])],17]
case4=[range(par['ns']),[range(par['ns'])],range(par['ngx'])]
case5=[range(par['ns']),[range(par['ns'])],range(par['nx'])]

cases=[case0,case1,case2,case3,case4,case5]

customfd='jsnap=4 '

for m in (['-L','-C','-H']):


    ci=0

    for c in cases:
        ctag='-c%d'%ci 
    
        shots=c[0]


        ##########################################################################################
        #          Read and process the cases table, each case separately to make 
        #          sure it makes what I want it to do.
        ##########################################################################################
        if  ci==0:
            Flow('rr'+ctag,'rr','window f2=%s n2=1'%c[1])
            fdmod.point('gg'+ctag,3.0,c[2]*par['dz'] +par['oz'],par)
            
            tgrey='put n2=1 | transp |'

        elif ci==1:
            Flow('rr'+ctag,'rr','window f2=%s n2=1'%c[1])
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
            tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par

        elif ci==2:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
            tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par

        elif ci==3:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,'gg-%03d'%c[2],'window ')
            tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par

        elif ci==4:
            Flow('rr'+ctag,'rr','window ')
            Flow('gg'+ctag,map(lambda x:'gg-%03d'%x,c[2]),'cat axis=2 ${SOURCES[1:%d]}'%len(c[2]))
            tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g o3=%(ogx)g d3=%(dgx)g n3=%(ngx)d | transp |'%par

        elif ci==5:
            Flow('rr'+ctag,'rr','window ')
            fdmod.boxarray('gg'+ctag,par['nz'],par['oz'],par['dz'],par['nx'],par['ox'],par['dx'],par)
            tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g o3=%(ox)g d3=%(dx)g n3=%(nx)d | transp |'%par

        else:
            print "something wrong, probably I going to crash"
        ##########################################################################################
        ##########################################################################################


        Plot('gg'+ctag,fdmod.rrplot('plotcol=2',par))
        Plot('rr'+ctag,fdmod.ssplot('',par))
        Plot('ss'+ctag,map(lambda x:'s-%03d'%x,shots),'Overlay')


        for ishot in shots:
            stag='-%03d'%ishot

            fdmod.awefd('dmod_tmp'+ctag+stag+m,'us'+ctag+stag+m,'wav','vel'+m,'den','s'+stag,'rr',customfd,par)
            if ci<2:
                Flow('dat_s'+stag+ctag,'dat_tmps'+stag,'window f1=%s n1=1 squeeze=n'%c[1])
                # Computing state variables us and ur
                Flow('dmod'+ctag+stag+m,['dmod_tmp'+ctag+stag+m],'window f1=%s n1=1 squeeze=n'%c[1])
            else:
                Flow('dat_s'+stag+ctag,'dat_s-%03d'%ishot,'window squeeze=n')
                # Computing state variables us and ur
                Flow('dmod'+ctag+stag+m,['dmod_tmp'+ctag+stag+m],'window squeeze=n')


                   
            #Flow('dres'+ctag+stag+m,['dmod'+ctag+stag+m,'dat_s'+stag+ctag],'window squeeze=n')

            fdmod.awefd_rwfl('ur'+ctag+stag+m,'dat_s'+stag+ctag,'vel'+m,'den','rr'+ctag,customfd,par)
            fdmod.awefd_rwfl('urmod'+ctag+stag+m,'dmod'+ctag+stag+m,'vel'+m,'den','rr'+ctag,customfd,par)

            # Compute of conventional image
            Flow('img'+ctag+stag+m,['us'+ctag+stag+m,'urmod'+ctag+stag+m],
                '''
                tpow pow3=1.5 >tmp1.rsf; 
                <${SOURCES[1]} $RSFROOT/bin/sftpow pow3=1.5 >tmp2.rsf ;
                $RSFROOT/bin/sfxcor2d<tmp1.rsf uu=tmp2.rsf axis=3 verb=y nbuf=200 >$TARGET;
                 $RSFROOT/bin/sfrm tmp1.rsf tmp2.rsf
                ''' % par,stdout=0)


            Flow('rimg'+ctag+stag+m,['us'+ctag+stag+m,'urmod'+ctag+stag+m],
                '''
                xcor2d axis=3 verb=n nbuf=200 uu=${SOURCES[1]}
                ''')


            Flow('imgz'+ctag+stag+m,'img'+ctag+stag+m,'envelope |smooth rect1=10 rect2=10 repeat=10|transp plane=23|math output="input+1e-22"|scale axis=2|transp plane=23')    
            # Extended imaging condition and only one location for every shot
            wemig.eic('eic'+ctag+stag+m,'us'+ctag+stag+m,'ur'+ctag+stag+m,'gg'+ctag,'nhx=0 nhz=0 nht=%(nht)d|window squeeze=y'%par,par)
            wemig.eic('eica'+ctag+stag+m,'us'+ctag+stag+m,'urmod'+ctag+stag+m,'gg'+ctag,'nhx=0 nhz=0 nht=%(nht)d|window squeeze=y'%par,par)


            if ci<1:
                Flow('pen_eic'+ctag+stag+m,['eic'+ctag+stag+m],'scale axis=123|math output="(x1*input)*exp(-((x1^2)/(.2^2)))" ')
                
            elif ci>0 and ci<4:
                Flow('mask_eic'+ctag+stag+m,'eica'+ctag+stag+m,
                     '''
                     envelope| smooth rect1=3 rect2=10 repeat=10 |
                     window n1=1 min1=0 |scale axis=123|
                     math output="input^2.5"| 
                     spray axis=1 n=%d d=%g o=%g
                     '''%(par['nht']*2+1,par['dht'],-par['nht']*par['dht']))

                Flow('pen_eic'+ctag+stag+m,['eic'+ctag+stag+m,'mask_eic'+ctag+stag+m],'scale axis=123|math output="(x1*input)*exp(-((x1^2)/(.2^2)))"|add mode=p ${SOURCES[1]}')
                #Flow('pen_eic'+ctag+stag+m,['eic'+ctag+stag+m,'mask_eic'+ctag+stag+m],'bandpass flo=10|math output="(x1*input)*exp(-((x2-1.25)^2/(.2*.2)))"')
            elif ci==4:
                Flow('mask_eic'+ctag+stag+m,'eica'+ctag+stag+m,
                     '''
                     envelope| put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=%(ngx)d d3=%(dgx)g o3=%(ogx)g label1="ht"|smooth rect1=3 rect2=10 repeat=10 |
                     window n1=1 min1=0 |scale axis=3|
                     math output="input^2"| 
                     '''%par +
                     '''
                     spray axis=1 n=%d d=%g o=%g|
                     scale axis=2 |
                     '''%(par['nht']*2+1,par['dht'],-par['nht']*par['dht'])+
                     '''
                     put n2=%d d2=%g o2=0
                     '''%(par['nz']*par['ngx'],par['dx']))

                Flow('pen_eic'+ctag+stag+m,['eic'+ctag+stag+m,'mask_eic'+ctag+stag+m],'scale axis=123|math output="(x1*input)*exp(-((x1^2)/(.2^2)))"|add mode=p ${SOURCES[1]} ')
            else:

#                Flow('mask_eic'+ctag+stag+m,'eica'+ctag+stag+m,
#                     '''
#                     envelope| put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=%(nx)d d3=%(dx)g o3=%(ox)g label1="ht"|smooth rect1=1 rect2=10 repeat=10 |
#                     smooth rect3=1  repeat=1|
#                     window n1=1 min1=0 |scale axis=3|
#                     math output="input^1"| 
#                     '''%par +
#                     '''
#                     spray axis=1 n=%d d=%g o=%g|
#                     math output="(input +1.0e-22)" |
#                     scale axis=2 |
#                     '''%(par['nht']*2+1,par['dht'],-par['nht']*par['dht'])+
#                     '''
#                     put n2=%d d2=%g o2=0 n3=1
#                     '''%(par['nz']*par['nx'],par['dx']))
                Flow('mask_eic'+ctag+stag+m,'imgz'+ctag+stag+m,
                    ''' spray axis=3 n=%d d=%g o=%g '''%(par['nht']*2+1,par['dht'],-2*par['nht']*par['dht'])
                    +'''|transp plane=13 memsize=8000|transp memsize=9000 plane=23 |
                        put n3=1 n2=%d
                        '''%(par['nx']*par['nz']))

                Flow('pen_eic'+ctag+stag+m,['eic'+ctag+stag+m,'mask_eic'+ctag+stag+m],'scale dscale=1.0e+15 |math output="(x1*input)*exp(-((x1^2)/(.2^2)))"|add mode=p ${SOURCES[1]}')

                Result('mask_2d'+stag+m,'mask_eic'+ctag+stag+m,
                     '''
                     put n2=%(nz)d o2=%(oz)g d2=%(dz)g n3=%(nx)d d3=%(dx)g  o3=%(ox)g |
                     window n1=1| 
                     '''%par+fdmod.cgrey('',par))

                

    
            # Adjoint source, receiver side
            Flow('adj_r'+ctag+stag+m,['us'+ctag+stag+m,'pen_eic'+ctag+stag+m,'gg'+ctag,'wav_'],
                 '''
                 ./sfadjsrc_mva2_omp.exe eic=${SOURCES[1]} coord=${SOURCES[2]} source=1 verb=1 |
                  sinc pattern=${SOURCES[3]} | transp plane=12  memsize=8000
                 ''')
            # Adjoint source, source side
            Flow('adj_s'+ctag+stag+m,['ur'+ctag+stag+m,'pen_eic'+ctag+stag+m,'gg'+ctag,'wav_'],
                 '''
                 ./sfadjsrc_mva2_omp.exe eic=${SOURCES[1]} coord=${SOURCES[2]} source=0 verb=1 |
                 sinc pattern=${SOURCES[3]} | transp plane=12 memsize=8000
                 ''')
    
            # Adjoint state variables
            fdmod.awefd_rwfl('as'+ctag+stag+m,'adj_s'+ctag+stag+m,'vel'+m,'den','gg'+ctag,customfd,par)
            fdmod.awefd_swfl('ar'+ctag+stag+m,'adj_r'+ctag+stag+m,'vel'+m,'den','gg'+ctag,customfd,par)
    
            # Gradient calculation 
            # sgrad:  source side gradient 
            #      sgrad = \int us*as dt
            # rgrad:  source side gradient 
            #      rgrad = \int ur*ar dt
    
            custom='deriv3 axis=3|deriv3 axis=3 |xcor2d uu=${SOURCES[1]} axis=3 verb=y nbuf=100'
            Flow('sgrad'+ctag+stag+m,['us'+ctag+stag+m,'as'+ctag+stag+m],custom)
            Flow('rgrad'+ctag+stag+m,['ur'+ctag+stag+m,'ar'+ctag+stag+m],custom)
    
    
            #plotting of gradients
            Plot('sgrad'+ctag+stag+m,fdmod.cgrey('color=E pclip=99.9',par))
            Result('sgrad'+ctag+stag+m,['sgrad'+ctag+stag+m,'gg'+ctag,'rr'+ctag,'ss'+ctag],'Overlay')

            Plot('rgrad'+ctag+stag+m,fdmod.cgrey('color=E pclip=99.9',par))
            Result('rgrad'+ctag+stag+m,['rgrad'+ctag+stag+m,'gg'+ctag,'rr'+ctag,'ss'+ctag],'Overlay')


        Flow('eic'+ctag+m,map(lambda x:'eic'+ctag+'-%03d'%x+m,shots),'add ${SOURCES[1:%d]}'%len(shots))
        Flow('pen_eic'+ctag+m,map(lambda x:'pen_eic'+ctag+'-%03d'%x+m,shots),'add ${SOURCES[1:%d]}'%len(shots))





        

        # stack of individual gradient contributions
        # total source gradient
        Flow('sgrad'+ctag+m,map(lambda x:'sgrad'+ctag+'-%03d'%x+m,shots),'add scale=1 ${SOURCES[1:%d]}'%len(shots))
   

        Result('sgrad'+ctag+m,map(lambda x:'sgrad'+ctag+'-%03d'%x+m,shots),'Movie')
 
        # totall receiver gradient
        Flow('rgrad'+ctag+m,map(lambda x:'rgrad'+ctag+'-%03d'%x+m,shots),'add scale=1 ${SOURCES[1:%d]}'%len(shots))
        Result('rgrad'+ctag+m,map(lambda x:'rgrad'+ctag+'-%03d'%x+m,shots),'Movie')
    
        # total gradient:  sgrad + rgrad
        Flow('grad'+ctag+m,['sgrad'+ctag+m,'rgrad'+ctag+m],'add scale=1 ${SOURCES[1]} ')
    

        ci+=1



Plot('rimg-c1-005-L',fdmod.cgrey('pclip=99.5',par))
Result('img-c1-005-L-gg',['rimg-c1-005-L','gg-c2'],'Overlay')
Result('img-c1-005-L','gg-c2 rimg-c1-005-L','Overlay')

Result('eica-c2-005-L','eica-c2-005-L','put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par+adcig.tgrey('',par))
Result('mask_eica-c2-005-L','eica-c2-005-L',
    '''
    envelope| smooth rect1=3 rect2=10 repeat=10 |
    scale axis=123 |
    math output="input^2.5"|
    put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|
    '''%par+adcig.tgrey('allpos=y',par))

Result('I_mask_eica-c2-005-L','eica-c2-005-L',
    '''
    envelope| smooth rect1=3 rect2=10 repeat=10 |
    math output="input^2.5"|
    sfwindow f1=220 n1=1 |scale axis=123 |
    sfgraph parallel2=n labelrot=n wantaxis=y title="" pclip=100 gainpanel=a 
    min1=0 max1=2.49 label1=z unit1=km screenratio=1.5 labelsz=6 labelfat=3 titlesz=12
    titlefat=3 parallel2=n labelsz=6 labelfat=3 titlesz=12 titlefat=3 label2="I(x)"  
    n1tic=2 screenratio=1 xll=2 yll=1 allpos=y transp=y wherexlabel=t
    ''')




ci=0
for c in cases:
    ctag='-c%d'%ci 

    Flow('grad-byte'+ctag,map(lambda x:'grad'+ctag+'%s'% x,['-L','-C','-H']),'rcat axis=3 ${SOURCES[1:3]}|byte gainpanel=a pclip=100')
    Result('case'+ctag,['vel-c','ss'+ctag,'gg'+ctag,'rr'+ctag],'Overlay')




    Flow('eic-byte'+ctag,map(lambda x:'eic'+ctag+'%s'% x,['-L','-C','-H']),'rcat axis=3 ${SOURCES[1:3]}|byte gainpanel=a pclip=99.5')
    Flow('pen_eic-byte'+ctag,map(lambda x:'pen_eic'+ctag+'%s'% x,['-L','-C','-H']),'rcat axis=3 ${SOURCES[1:3]}|byte gainpanel=a pclip=99.5')

    if  ci==0:
        tgrey='put n2=1 | transp |'
    elif ci==1:
        tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par
    elif ci==2:
        tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par
    elif ci==3:
        tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g n3=1 | transp|'%par
    elif ci==4:
        tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g o3=%(ogx)g d3=%(dgx)g n3=%(ngx)d | transp |'%par

    elif ci==5:
        tgrey='put n2=%(nz)d d2=%(dz)g o2=%(oz)g o3=%(ox)g d3=%(dx)g n3=%(nx)d | transp |'%par
    else:
        print "something wrong, probably I going to crash"

    nm=0


    for m in (['-L','-C','-H']):
        
        Plot('grad'+ctag+m,'grad-byte'+ctag,'window f3=%d n3=1 |'%nm+fdmod.cgrey('color=E ',par))
        Result ('grad'+ctag+m,['grad'+ctag+m,'ss'+ctag,'rr'+ctag],'Overlay')

        Result('eic'+ctag+m,'eic-byte'+ctag,'window f3=%d n3=1|'%nm+tgrey+adcig.tgrey('grid1=y',par))
        Result('pen_eic'+ctag+m,'pen_eic-byte'+ctag,'window f3=%d n3=1|'%nm+tgrey+adcig.tgrey('grid1=y',par))
    
        nm+=1 


    ci+=1

End()
